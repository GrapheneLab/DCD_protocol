<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>
index
</title>
</head>
<body>

<h1>Reference implementation for proposed SG14 <code>status_code</code> (<code>&lt;system_error2&gt;</code>) in C++ 11</h1>
<p>(C) 2018 Niall Douglas <a href="http://www.nedproductions.biz/">http://www.nedproductions.biz/</a>
Please send feedback to the SG14 study group mailing list at <a href="https://groups.google.com/a/isocpp.org/d/forum/sg14">https://groups.google.com/a/isocpp.org/d/forum/sg14</a>.</p>
<p>Docs: <a href="https://ned14.github.io/status-code/">https://ned14.github.io/status-code/</a>
(reference API docs are at bottom of page) Linux: <a href="https://travis-ci.org/ned14/status-code"><img alt="Build Status" src="https://travis-ci.org/ned14/status-code.svg?branch=master" /></a> Windows: <a href="https://ci.appveyor.com/project/ned14/status-code/branch/master"><img alt="Build status" src="https://ci.appveyor.com/api/projects/status/doyh9rol1gupcwd0/branch/master?svg=true" /></a></p>
<p>Solves the problems for low latency/large code base users with <code>&lt;system_error&gt;</code>
as listed by <a href="https://wg21.link/P0824">WG21 P0824</a>. This proposed <code>&lt;system_error2&gt;</code>
library is EXPERIMENTAL and is subject to change as the committee evolves the design.
To fetch a drop-in standalone single file implementation:</p>
<pre><code>wget https://github.com/ned14/status-code/raw/develop/single-header/system_error2.hpp
</code></pre>

<h2>Features:</h2>
<ul>
<li>Portable to any C++ 11 compiler. These are known to work:<ul>
<li>&gt;= GCC 5 (due to requiring libstdc++ 5 for sufficient C++ 11 type traits)</li>
<li>&gt;= clang 3.3 with a new enough libstdc++ (previous clangs don't implement inheriting constructors)</li>
<li>&gt;= Visual Studio 2015 (previous MSVC's don't implement inheriting constructors)</li>
</ul>
</li>
<li>Comes with built in POSIX, Win32, NT kernel, Microsoft COM and <code>std::error_code</code>
status code domains.</li>
<li>Implements <code>std::error</code> as proposed by <a href="https://wg21.link/P0709">P0709 Zero-overhead deterministic exceptions</a>.</li>
<li>Aims to cause zero code generated by the compiler most of the time.</li>
<li>Never calls <code>malloc()</code>.</li>
<li>Header-only library friendly.</li>
<li>Type safe yet with type erasure in public interfaces so it can scale
across huge codebases.</li>
<li>Minimum compile time load, making it suitable for use in the global headers of
multi-million line codebases.</li>
</ul>
<h2>Example of use:</h2>
<table width="100%">
<tr>
<th>POSIX</th>
<th>Windows</th>
</tr>
<tr>
<td valign="top">
<pre><code class="c++">using native_handle_type = int;
native_handle_type open_file(const char *path,
  system_error2::system_code &sc) noexcept
{
  sc.clear();  // clears to empty
  native_handle_type h = ::open(path, O_RDONLY);
  if(-1 == h)
  {
    // posix_code type erases into system_code
    sc = system_error2::posix_code(errno);
  }
  return h;
}
</code></pre>
</td>
<td valign="top">
<pre><code class="c++">using native_handle_type = HANDLE;
native_handle_type open_file(const wchar_t *path,
  system_error2::system_code &sc) noexcept
{
  sc.clear();  // clears to empty
  native_handle_type h = CreateFile(path, GENERIC_READ,
    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
    nullptr,
    OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL,
    nullptr
  );
  if(INVALID_HANDLE_VALUE == h)
  {
    // win32_code type erases into system_code
    sc = system_error2::win32_code(GetLastError());
  }
  return h;
}
</code></pre>
</td>
</tr>
<tr>
<th colspan="2">Portable code</th>
</tr>
<tr>
<td colspan="2">
<pre><code class="c++" style="display: inline-block; position: relative; left: 50%; transform: translateX(-50%);">system_error2::system_code sc;  // default constructs to empty
native_handle_type h = open_file(path, sc);
// Is the code a failure?
if(sc.failure())
{
  // Do semantic comparison to test if this was a file not found failure
  // This will match any system-specific error codes meaning a file not found
  if(sc != system_error2::errc::no_such_file_or_directory)
  {
    std::cerr << "FATAL: " << sc.message().c_str() << std::endl;
    std::terminate();
  }
}
</code></pre>
</tr>
</table>

<h2>Problems with <code>&lt;system_error&gt;</code> solved:</h2>
<ol>
<li>
<p>Does not cause <code>#include &lt;string&gt;</code>, and thus including the entire STL allocator and algorithm
machinery, thus preventing use in freestanding C++ as well as substantially
impacting compile times which can be a showstopper for very large C++ projects.
Only includes the following headers:</p>
<ul>
<li><code>&lt;atomic&gt;</code> to reference count localised strings retrieved from the OS.</li>
<li><code>&lt;cassert&gt;</code> to trap when misuse occurs.</li>
<li><code>&lt;cerrno&gt;</code> for the generic POSIX error codes (<code>errno</code>) which is required to define <code>errc</code>.</li>
<li><code>&lt;cstddef&gt;</code> for the definition of <code>size_t</code> and other types.</li>
<li><code>&lt;cstring&gt;</code> for the system call to fetch a localised string and C string functions.</li>
<li><code>&lt;exception&gt;</code> for the basic <code>std::exception</code> type so we can optionally throw STL exceptions.</li>
<li><code>&lt;initializer_list&gt;</code> so we can permit in-place construction.</li>
<li><code>&lt;new&gt;</code> so we can perform placement new.</li>
<li><code>&lt;type_traits&gt;</code> as we need to do some very limited metaprogramming.</li>
<li><code>&lt;utility&gt;</code> if on C++ 17 or later for <code>std::in_place</code>.</li>
</ul>
<p>All of the above headers are on the "fast parse" list at https://github.com/ned14/stl-header-heft.</p>
<p>These may look like a lot, but in fact just including <code>&lt;atomic&gt;</code> on libstdc++ actually
brings in most of the others in any case, and a total of 200Kb (8,000 lines) of text is including by
<code>system_error2.hpp</code> on libstdc++ 7. Compiling a file including <code>status_code.hpp</code> takes
less than 150 ms with clang 3.3 as according to the <code>-ftime-report</code> diagnostic (a completely
empty file takes 5 ms).</p>
</li>
<li>
<p>Unlike <code>std::error_code</code> which was designed before <code>constexpr</code>, this proposed
implementation has all-<code>constexpr</code> construction and destruction with as many operations
as possible being trivial or literal, with only those exact minimum operations which
require runtime code generation being non-trivial (note: requires C++ 14 for a complete
implementation of this).</p>
</li>
<li>
<p>This in turn means that we solve a long standing problem with <code>std::error_category</code>
in that it is not possible to define a safe custom C++ 11 error category in a header
only library where semantic comparisons would randomly break depending on the direction of wind
blowing when the linker ran. This proposed design is 100% safe to use in header only libraries.</p>
</li>
<li>
<p><code>std::error_code</code>'s boolean conversion operator i.e. <code>if(ec) ...</code> has become
unfortunately ambiguous in real world C++ out there. Its correct meaning is
"if <code>ec</code> has a non-zero value". Unfortunately, much code out in the wild uses
it as if "if <code>ec</code> is errored". This is incorrect, though safe most of the time
where <code>ec</code>'s category is well known i.e. non-zero values are always an error.
For unknown categories supplied by third party code however, it is dangerous and leads
to unpleasant, hard-to-debug, surprise.</p>
<p>The <code>status_code</code> proposed here suffers from no such ambiguity. It can be one of
exactly three meanings: (i) success (ii) failure (iii) empty (uninitialised). There
is no boolean conversion operator, so users must write out exactly what they mean
e.g. <code>if(sc.success()) ...</code>, <code>if(sc.failure()) ...</code>, <code>if(sc.empty()) ...</code>.</p>
</li>
<li>
<p>Relatedly, <code>status_code</code> can now represent successful (informational) codes as
well as failure codes. Unlike <code>std::error_code</code> where zero is given special meaning,
we impose no requirements at all on the choice of coding. This permits safe usage of more
complex C status coding such as the NT kernel's <code>NTSTATUS</code>, which is a <code>LONG</code> whereby bits
31 and 30 determine which of four categories the status is (success, informational, warning,
error), or the very commone case where negative numbers mean failure and positive numbers
mean success-with-information.</p>
</li>
<li>
<p>The relationship between <code>std::error_code</code> and <code>std::error_condition</code> is
confusing to many users reading code based on <code>&lt;system_error&gt;</code>, specifically when is
a comparison between codes <em>semantic</em> or <em>literal</em>? <code>status_code</code> makes all
comparisons <em>semantic</em>, <strong>always</strong>. If you want a literal comparison, you can do one
by hand by comparing domains and values directly.</p>
</li>
<li>
<p><code>std::error_code</code> enforced its value to always be an <code>int</code>. This is problematic
for coding systems which might use a <code>long</code> and implement coding namespaces within
the extended number of bits, or for end users wishing to combine a code with a <code>void *</code>
in order to transmit payload or additional context. As a result, <code>status_code</code> is
templated to its domain, and the domain sets its type. A type erased edition of
<code>status_code&lt;D&gt;</code> is available as <code>status_code&lt;void&gt;</code>, this is for obvious reasons
non-copyable, non-movable and non-destructible.</p>
<p>A more useful type erased edition is <code>status_code&lt;erased&lt;T&gt;&gt;</code> 
which is available if <code>D::value_type</code> is trivially copyable, <code>T</code> is an integral
type, and <code>sizeof(T) &gt;= sizeof(D::value_type)</code>. This lets you use
<code>status_code&lt;erased&lt;T&gt;&gt;</code> in all your public interfaces without
restrictions. As a pointer to the original category is retained, and trivially
copyable types may be legally copied by <code>memcpy()</code>, type erased status codes
work exactly as normal, except that publicly it does not advertise its type.</p>
</li>
<li>
<p><code>std::system_category</code> assumes that there is only one "system" error coding,
something mostly true on POSIX, but not elsewhere. This library defines
<code>system_code</code> to a type erased status code sufficiently large enough to carry
any of the system error codings on the current platform. This allows code to
construct the precise error code for the system failure in question, and
return it type erased from the function. Depending on the system call which
failed, a function may therefore return any one of many system code domains.</p>
</li>
<li>
<p>Too much <code>&lt;system_error&gt;</code> code written for POSIX uses <code>std::generic_category</code>
when they really meant <code>std::system_category</code> because the two are interchangeable
on POSIX. Further confusion stems from <code>std::error_condition</code> also sharing the same
coding and type. This causes portability problems. This library's <code>generic_code</code> has
a value type of <code>errc</code> which is a strong enum. This prevents implicit confusion
with <code>posix_code</code>, whose value type is an <code>int</code> same as <code>errno</code> returns. There is
no distinction between codes and conditions in this library, rather we treat
<code>generic_code</code> as something special, because it represents <code>errc</code>. The cleanup
of these ambiguities in <code>&lt;system_error&gt;</code> should result in users writing clearer
code with fewer unintended portability problems.</p>
</li>
</ol>
<h1>Project index</h1>
<ul>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_CONSTEXPR14"><code>SYSTEM_ERROR2_CONSTEXPR14</code></a> &mdash; Defined to be <code>constexpr</code> when on C++ 14 or better compilers. Usually automatic, can be overriden.</p>
</li>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_FATAL"><code>SYSTEM_ERROR2_FATAL</code></a> &mdash; Prints msg to stderr, and calls <code>std::terminate()</code>. Can be overriden via predefinition.</p>
</li>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_NAMESPACE"><code>SYSTEM_ERROR2_NAMESPACE</code></a> &mdash; The system_error2 namespace name.</p>
</li>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_NAMESPACE_BEGIN"><code>SYSTEM_ERROR2_NAMESPACE_BEGIN</code></a> &mdash; Begins the system_error2 namespace.</p>
</li>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_NAMESPACE_END"><code>SYSTEM_ERROR2_NAMESPACE_END</code></a> &mdash; Ends the system_error2 namespace.</p>
</li>
<li>
<p><a href="doc_config.html#standardese-config-hpp"><code>SYSTEM_ERROR2_NODISCARD</code></a></p>
</li>
<li>
<p><a href="doc_config.html#standardese-config-hpp"><code>SYSTEM_ERROR2_NORETURN</code></a></p>
</li>
<li>
<h2>Namespace <code>system_error2</code></h2>
<p><span id="standardese-system_error2"></span></p>
<p>Namespace for the library</p>
<ul>
<li>
<p><a href="doc_com_code.html#standardese-system_error2___com_code_domain"><code>_com_code_domain</code></a> &mdash; (Windows only) The implementation of the domain for COM error codes and/or <code>IErrorInfo</code>.</p>
</li>
<li>
<p><a href="doc_std_error_code.html#standardese-system_error2___error_code_domain-error_code_type-make_categories_type-"><code>_error_code_domain</code></a> &mdash; The implementation of the domain for <code>std::error_code</code> error codes.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2___generic_code_domain"><code>_generic_code_domain</code></a> &mdash; The implementation of the domain for generic status codes, those mapped by <code>errc</code> (POSIX).</p>
</li>
<li>
<p><a href="doc_nt_code.html#standardese-system_error2___nt_code_domain"><code>_nt_code_domain</code></a> &mdash; (Windows only) The implementation of the domain for NT error codes, those returned by NT kernel functions.</p>
</li>
<li>
<p><a href="doc_posix_code.html#standardese-system_error2___posix_code_domain"><code>_posix_code_domain</code></a> &mdash; The implementation of the domain for POSIX error codes, those returned by <code>errno</code>.</p>
</li>
<li>
<p><a href="doc_win32_code.html#standardese-system_error2___win32_code_domain"><code>_win32_code_domain</code></a> &mdash; (Windows only) The implementation of the domain for Win32 error codes, those returned by <code>GetLastError()</code>.</p>
</li>
<li>
<p><a href="doc_com_code.html#standardese-system_error2__com_code"><code>com_code</code></a> &mdash; (Windows only) A COM error code. Note semantic equivalence testing is only implemented for <code>FACILITY_WIN32</code> and <code>FACILITY_NT_BIT</code>. As you can see at <a href="https://blogs.msdn.microsoft.com/eldar/2007/04/03/a-lot-of-hresult-codes/">https://blogs.msdn.microsoft.com/eldar/2007/04/03/a-lot-of-hresult-codes/</a>, there are an awful lot of COM error codes, and keeping mapping tables for all of them would be impractical (for the Win32 and NT facilities, we actually reuse the mapping tables in <code>win32_code</code> and <code>nt_code</code>).</p>
</li>
<li>
<p><a href="doc_com_code.html#standardese-system_error2__com_code_domain"><code>com_code_domain</code></a> &mdash; (Windows only) A constexpr source variable for the COM code domain. Returned by <code>_com_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_com_code.html#standardese-system_error2__com_error"><code>com_error</code></a> &mdash; (Windows only) A specialisation of <code>status_error</code> for the COM error code domain.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2"><code>equivalent</code></a></p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__erased-ErasedType--"><code>erased</code></a> &mdash; A tag for an erased value type for <code>status_code&lt;D&gt;</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__errc"><code>errc</code></a> &mdash; The generic error coding (POSIX)</p>
</li>
<li>
<p><a href="doc_error.html#standardese-system_error2__error"><code>error</code></a> &mdash; An erased <code>system_code</code> which is always a failure. The closest equivalent to <code>std::error_code</code>, except it cannot be null and cannot be modified.</p>
</li>
<li>
<p><a href="doc_errored_status_code.html#standardese-system_error2__errored_status_code-DomainType-"><code>errored_status_code</code></a> &mdash; A <code>status_code</code> which is always a failure. The closest equivalent to <code>std::error_code</code>, except it cannot be modified, and is templated.</p>
</li>
<li>
<p><a href="doc_status_code_domain.html#standardese-system_error2__generic_code"><code>generic_code</code></a> &mdash; The generic code is a status code with the generic code domain, which is that of <code>errc</code> (POSIX).</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__generic_code_domain"><code>generic_code_domain</code></a> &mdash; A constexpr source variable for the generic code domain, which is that of <code>errc</code> (POSIX). Returned by <code>_generic_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__generic_error"><code>generic_error</code></a> &mdash; A specialisation of <code>status_error</code> for the generic code domain.</p>
</li>
<li>
<p><a href="doc_std_error_code.html#standardese-system_error2"><code>get</code></a></p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__in_place"><code>in_place</code></a> &mdash; Aliases <code>std::in_place</code> if on C++ 17 or later, else defined locally.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__in_place_t"><code>in_place_t</code></a> &mdash; Aliases <code>std::in_place_t</code> if on C++ 17 or later, else defined locally.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__is_status_code-T-"><code>is_status_code</code></a> &mdash; Trait returning true if the type is a status code.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2"><code>make_status_code</code></a></p>
</li>
<li>
<p><a href="doc_status_code_ptr.html#standardese-system_error2__make_status_code_ptr-T---T---"><code>make_status_code_ptr</code></a> &mdash; Make an erased status code which indirects to a dynamically allocated status code.</p>
</li>
<li>
<h3>Namespace <code>system_error2::mixins</code></h3>
<p><span id="standardese-system_error2__mixins"></span></p>
<p>Namespace for user injected mixins</p>
<ul>
<li><a href="doc_status_code.html#standardese-system_error2__mixins"><code>mixin</code></a></li>
</ul>
</li>
<li>
<p><a href="doc_nt_code.html#standardese-system_error2__nt_code"><code>nt_code</code></a> &mdash; (Windows only) A NT error code, those returned by NT kernel functions.</p>
</li>
<li>
<p><a href="doc_nt_code.html#standardese-system_error2__nt_code_domain"><code>nt_code_domain</code></a> &mdash; (Windows only) A constexpr source variable for the NT code domain, which is that of NT kernel functions. Returned by <code>_nt_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_nt_code.html#standardese-system_error2__nt_error"><code>nt_error</code></a> &mdash; (Windows only) A specialisation of <code>status_error</code> for the NT error code domain.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__operator---DomainType1-DomainType2--status_code-DomainType1-const--status_code-DomainType2-const--"><code>operator!=</code></a> &mdash; True if the status code’s are not semantically equal via <code>equivalent()</code>.</p>
</li>
<li>
<p><a href="doc_iostream_support.html#standardese-system_error2__operator---DomainType---std__ostream--status_code-DomainType-const--"><code>operator&lt;&lt;</code></a> &mdash; Print the status code to a <code>std::ostream &amp;</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__operator---DomainType1-DomainType2--status_code-DomainType1-const--status_code-DomainType2-const--"><code>operator==</code></a> &mdash; True if the status code’s are semantically equal via <code>equivalent()</code>.</p>
</li>
<li>
<p><a href="doc_posix_code.html#standardese-system_error2__posix_code"><code>posix_code</code></a> &mdash; A POSIX error code, those returned by <code>errno</code>.</p>
</li>
<li>
<p><a href="doc_posix_code.html#standardese-system_error2__posix_code_domain"><code>posix_code_domain</code></a> &mdash; A constexpr source variable for the POSIX code domain, which is that of <code>errno</code>. Returned by <code>_posix_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_posix_code.html#standardese-system_error2__posix_error"><code>posix_error</code></a> &mdash; A specialisation of <code>status_error</code> for the POSIX error code domain.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__ptr-StatusCode-"><code>ptr</code></a> &mdash; A tag for an unique pointer to a <code>StatusCode</code>.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__status_code-DomainType-"><code>status_code</code></a> &mdash; The main workhorse of the system_error2 library, can be typed (<code>status_code&lt;DomainType&gt;</code>), erased-immutable (<code>status_code&lt;void&gt;</code>) or erased-mutable (<code>status_code&lt;erased&lt;T&gt;&gt;</code>).</p>
</li>
<li>
<p><a href="doc_status_code_domain.html#standardese-system_error2__status_code_domain"><code>status_code_domain</code></a> &mdash; Abstract base class for a coding domain of a status code.</p>
</li>
<li>
<p><a href="doc_status_error.html#standardese-system_error2__status_error-DomainType-"><code>status_error</code></a> &mdash; Exception type representing a thrown status_code</p>
</li>
<li>
<p><a href="doc_std_error_code.html#standardese-system_error2__std_error_code"><code>std_error_code</code></a> &mdash; A wrapper of <code>std::error_code</code>.</p>
</li>
<li>
<p><a href="doc_std_error_code.html#standardese-system_error2__std_error_code_domain"><code>std_error_code_domain</code></a> &mdash; A constexpr source variable for the <code>std::error_code</code> code domain. Returned by <code>_error_code_domain&lt;error_code_type, detail::make_std_categoriesy&gt;::get()</code>.</p>
</li>
<li>
<p><a href="doc_system_code.html#standardese-system_error2__system_code"><code>system_code</code></a> &mdash; An erased-mutable status code suitably large for all the system codes which can be returned on this system.</p>
</li>
<li>
<p><a href="doc_system_code_from_exception.html#standardese-system_error2__system_code_from_exception-std__exception_ptr---system_error2__system_code-"><code>system_code_from_exception</code></a> &mdash; A utility function which returns the closest matching system_code to a supplied exception ptr.</p>
</li>
<li>
<h3>Namespace <code>system_error2::traits</code></h3>
<p><span id="standardese-system_error2__traits"></span></p>
<p>Namespace for user specialised traits</p>
<ul>
<li><a href="doc_config.html#standardese-system_error2__traits__is_move_relocating-T-"><code>is_move_relocating</code></a> &mdash; Specialise to true if you guarantee that a type is move relocating (i.e.</li>
</ul>
</li>
<li>
<p><a href="doc_win32_code.html#standardese-system_error2__win32_code"><code>win32_code</code></a> &mdash; (Windows only) A Win32 error code, those returned by <code>GetLastError()</code>.</p>
</li>
<li>
<p><a href="doc_win32_code.html#standardese-system_error2__win32_code_domain"><code>win32_code_domain</code></a> &mdash; (Windows only) A constexpr source variable for the win32 code domain, which is that of <code>GetLastError()</code> (Windows). Returned by <code>_win32_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_win32_code.html#standardese-system_error2__win32_error"><code>win32_error</code></a> &mdash; (Windows only) A specialisation of <code>status_error</code> for the Win32 error code domain.</p>
</li>
</ul>
</li>
</ul>
<h1>Worked example writing a custom status code domain and code</h1>
<p>In this worked example, we will implement a custom status code
domain whose code carries as payload a <code>std::exception_ptr</code> i.e.
a previously thrown C++ exception object. This will be somewhat
challenging as we shall be keeping our custom <code>status_code</code> trivially copyable
in order to preserve the type erasability into <code>status_code&lt;erased&lt;intptr_t&gt;&gt;</code>,
which in turn creates the problem of managing the lifetime of the
<code>std::exception_ptr</code>.</p>
<p>The way we will solve this is to keep a threadsafe global register of
<code>std::exception_ptr</code> instances. This could, of course, also be thread local
or use a wide variety of other methods of storage, but for here
we shall be keeping it simple.</p>
<h2>Storing the <code>std::exception_ptr</code> instances</h2>
<pre><code class="c++">#include &quot;system_error2.hpp&quot;

#include &lt;exception&gt;
#include &lt;mutex&gt;

static constexpr size_t max_exception_ptrs = 16;


using namespace SYSTEM_ERROR2_NAMESPACE;

struct exception_ptr_storage_t
{
  using index_type = unsigned int;

  mutable std::mutex lock;
  std::exception_ptr items[max_exception_ptrs];
  index_type idx{0};

  std::exception_ptr operator[](index_type i) const
  {
    std::lock_guard h(lock);
    return (idx - i &lt; max_exception_ptrs) ? items[i % max_exception_ptrs] : std::exception_ptr();
  }
  index_type add(std::exception_ptr p)
  {
    std::lock_guard h(lock);
    items[idx] = std::move(p);
    return idx++;
  }
};
inline exception_ptr_storage_t exception_ptr_storage;
</code></pre>

<p>The above is a fairly standard way of implementing a threadsafe
global register of instances. We keep <code>max_exception_ptrs</code>
instances, using modulus to convert some index id into a slot.
We detect when an index id refers to an instance whose slot
has been used by a more recent addition, and for that return
a null instance.</p>
<h2>Declaring <code>thrown_exception_code</code> and its domain</h2>
<pre><code class="c++">// Alias our new status code to its domain
class _thrown_exception_domain;
using thrown_exception_code = status_code&lt;_thrown_exception_domain&gt;;
</code></pre>

<p>As a general rule, one usually does not need to create a custom
status code implementation, typedefing it to a custom domain is
almost always sufficient. If you'd like status code to implicitly
construct from some type, you can write an ADL discovered function
called <code>make_status_code(T)</code> where <code>T</code> is the type you want
implicit construction from. Place the ADL discovered function into
the same namespace as <code>T</code>, and status code will find it. All
that said, you can of course inherit from <code>status_code&lt;YourDomain&gt;</code>
if you'd like, this can be useful if you have particularly custom
constructors.</p>
<pre><code class="c++">class _thrown_exception_domain : public status_code_domain
{
  // We permit status code to call our protected functions
  template &lt;class DomainType&gt; friend class status_code;
  using _base = status_code_domain;

public:
  // Our value type is the index into the exception_ptr storage
  using value_type = exception_ptr_storage_t::index_type;
</code></pre>

<p>status code does not <em>require</em> trivial copyability, but you are highly
advised to use a value type which is trivially copyable as then
the compiler can store the code in CPU registers rather than memory. This
leads to higher quality codegen.</p>
<p>It also enables type erasure into the copyable and moveable form
of status code i.e. <code>status_code&lt;erased&lt;T&gt;&gt;</code>. If your value type
is not trivially copyable, you only have the immutable form of
type erased status code available <code>status_code&lt;void&gt;</code>.</p>
<pre><code class="c++">  // std::exception::what() returns const char *, so the default string_ref is sufficient
  using _base::string_ref;

  // Always use https://www.random.org/cgi-bin/randbyte?nbytes=8&amp;format=h to create a
  // unique 64 bit value for every unique domain you create!
  constexpr _thrown_exception_domain() noexcept : _base(0xb766b5e50597a655) {}
</code></pre>

<p>Code domains use a unique 64 bit id to identify themselves. This
allows multiple singletons to exist and correctly compare equal.
The all-constexpr construction and destruction of the code domain
ensures that the compiler will assume that the domain can be assumed
to not have unique instancing i.e. the id comparison will generally
be compiled out as it is considered part of the domain's type.</p>
<pre><code class="c++">  // Default all the copy, move and destruct. This makes the type 100% constexpr in every way
  // which in turns allows the compiler to assume it will not be instantiated at runtime.
  _thrown_exception_domain(const _thrown_exception_domain &amp;) = default;
  _thrown_exception_domain(_thrown_exception_domain &amp;&amp;) = default;
  _thrown_exception_domain &amp;operator=(const _thrown_exception_domain &amp;) = default;
  _thrown_exception_domain &amp;operator=(_thrown_exception_domain &amp;&amp;) = default;
  ~_thrown_exception_domain() = default;

  // Fetch a constexpr instance of this domain
  static inline constexpr const _thrown_exception_domain *get();

  // Return the name of this domain
  virtual _base::string_ref name() const noexcept override final { return _base::string_ref(&quot;thrown exception&quot;); }
</code></pre>

<p>You can customise your implementation of <code>string_ref</code> to implement
reference counting or other lifetime management of strings returned
by the domain. This lets you fetch a string in the current locale
into a memory allocation, and once nobody is using it, it can be
deallocated. The built-in domains of <code>posix_code</code>, <code>win32_code</code> etc
do exactly this, so examine their source code for an example of how
to implement atomics-based threadsafe reference counting.</p>
<p>The <code>name()</code> is the first pure virtual function which all implementations
of <code>status_code_domain</code> must implement.</p>
<pre><code class="c++">protected:
  // This internal routine maps an exception ptr onto a generic_code
  // It is surely hideously slow, but that's all relative in the end
  static errc _to_generic_code(value_type c) noexcept
  {
    try
    {
      std::exception_ptr e = exception_ptr_storage[c];
      if(!e)
        return errc::unknown;
      std::rethrow_exception(e);
    }
    catch(const std::invalid_argument &amp; /*unused*/)
    {
      return errc::invalid_argument;
    }
    catch(const std::domain_error &amp; /*unused*/)
    {
      return errc::argument_out_of_domain;
    }
    catch(const std::length_error &amp; /*unused*/)
    {
      return errc::argument_list_too_long;
    }
    catch(const std::out_of_range &amp; /*unused*/)
    {
      return errc::result_out_of_range;
    }
    catch(const std::logic_error &amp; /*unused*/) /* base class for this group */
    {
      return errc::invalid_argument;
    }
    catch(const std::system_error &amp;e) /* also catches ios::failure */
    {
      return static_cast&lt;errc&gt;(e.code().value());
    }
    catch(const std::overflow_error &amp; /*unused*/)
    {
      return errc::value_too_large;
    }
    catch(const std::range_error &amp; /*unused*/)
    {
      return errc::result_out_of_range;
    }
    catch(const std::runtime_error &amp; /*unused*/) /* base class for this group */
    {
      return errc::resource_unavailable_try_again;
    }
    catch(const std::bad_alloc &amp; /*unused*/)
    {
      return errc::not_enough_memory;
    }
    catch(...)
    {
    }
    return errc::unknown;
  }
</code></pre>

<p><code>errc</code> is a slight superset of <code>std::errc</code>, but ia otherwise identical.
It has a special place in <code>&lt;system_error2&gt;</code> because it is the value type
of the <code>generic_code</code> status code, and all other status codes are expected
to "speak" <code>generic_code</code>. We therefore need a way of mapping the thrown
C++ exception into a <code>errc</code>, so we rethrow it and catch all of the STL
exception types, returning their equivalent <code>errc</code> code. This function
will be used in two parts of the code domain's implementation shortly.</p>
<pre><code class="c++">  // Always true, as exception_ptr always represents failure
  virtual bool _failure(const status_code&lt;void&gt; &amp;code) const noexcept override final
  {
    assert(code.domain() == *this);
    return true;
  }
</code></pre>

<p>This is the second pure virtual function which all implementations
of <code>status_code_domain</code> must implement. Each code might have multiple
success or failure states, and this function must return true if the
code given represents a failure. In this domain's case, all thrown
exceptions represent failure. So we always return true.</p>
<pre><code class="c++">  // True if the exception ptr is equivalent to some other status code
  virtual bool _equivalent(const status_code&lt;void&gt; &amp;code1, const status_code&lt;void&gt; &amp;code2) const noexcept override final
  {
    assert(code1.domain() == *this);
    const auto &amp;c1 = static_cast&lt;const thrown_exception_code &amp;&gt;(code1);
    if(code2.domain() == *this)
    {
      const auto &amp;c2 = static_cast&lt;const thrown_exception_code &amp;&gt;(code2);
      // Always perform literal comparison when domains are equal. The fallback
      // semantic comparison of converting both to generic_code and comparing
      // will handle semantic comparison of the same domain.
      return c1.value() == c2.value();
    }
    // If anything in your coding matches anything in errc, you should match it here
    if(code2.domain() == generic_code_domain)
    {
      const auto &amp;c2 = static_cast&lt;const generic_code &amp;&gt;(code2);
      if(c2.value() == _to_generic_code(c1.value()))
      {
        return true;
      }
    }
    return false;
  }
</code></pre>

<p>This third pure virtual function implementation is the heart of the
implementation of semantic comparisons. Semantic comparisons are implemented
as follows:</p>
<pre><code>1. If the two codes are empty, they are equivalent.
2. Ask the first code's domain if its code is `_equivalent()` to the second code.
3. Ask the second code's domain if its code is `_equivalent()` to the first code.
4. Map the second code to its nearest generic code, and ask the first
code's domain if its code is `_equivalent()` to the nearest generic code.
5. Map the first code to its nearest generic code, and ask the second
code's domain if its code is `_equivalent()` to the nearest generic code.
</code></pre>
<p>In <code>_equivalent()</code>, we always first check if the other domain is us,
if so we do a literal comparison knowing that the generic mapping
fallback will handle the semantic comparison of codes of the same domain.
If the other domain is the generic code domain, we map our thrown
exception to <code>errc</code> as described earlier, and if that is the same
we return true.</p>
<p>You can of course also do matching on any other custom domain of
your choice. For example, <code>com_code</code> also recognises <code>win32_code</code> and
<code>nt_code</code> during <code>_equivalent()</code>. You can examine its source code if
you'd like to know more.</p>
<pre><code class="c++">  // Called as a fallback if _equivalent() fails
  virtual generic_code _generic_code(const status_code&lt;void&gt; &amp;code) const noexcept override final
  {
    assert(code.domain() == *this);
    const auto &amp;c1 = static_cast&lt;const thrown_exception_code &amp;&gt;(code);
    return generic_code(_to_generic_code(c1.value()));
  }
</code></pre>

<p>This fourth of the pure virtual functions in <code>status_code_domain</code>
is fairly self explanatory.</p>
<pre><code class="c++">  // Extract the what() from the exception
  virtual _base::string_ref _message(const status_code&lt;void&gt; &amp;code) const noexcept override final
  {
    assert(code.domain() == *this);
    const auto &amp;c = static_cast&lt;const thrown_exception_code &amp;&gt;(code);
    try
    {
      std::exception_ptr e = exception_ptr_storage[c.value()];
      if(!e)
        return _base::string_ref(&quot;expired&quot;);
      std::rethrow_exception(e);
    }
    catch(const std::exception &amp;x)
    {
      return _base::string_ref(x.what());
    }
    catch(...)
    {
      return _base::string_ref(&quot;unknown thrown exception&quot;);
    }
  }
</code></pre>

<p>Usefully, <code>std::exception</code> provides a <code>what()</code> function returning
a <code>const char *</code>. So we don't need to implement extra lifetime
management as the exception ptr holds open the message string for
us. Therefore we simply rethrow the exception, catch any 
<code>std::exception</code> implementations and return their <code>what()</code> string.
A nicer fallback might be to extract the type of the exception from
<code>typeid()</code> and return that, that is left to the reader to implement.</p>
<pre><code class="c++">  // Throw the code as a C++ exception
  virtual void _throw_exception(const status_code&lt;void&gt; &amp;code) const override final
  {
    assert(code.domain() == *this);
    const auto &amp;c = static_cast&lt;const thrown_exception_code &amp;&gt;(code);
    std::exception_ptr e = exception_ptr_storage[c.value()];
    std::rethrow_exception(e);
  }
};
</code></pre>

<p>The final pure virtual function which must be implemented is how
best to throw the status code as a C++ exception. In this case
this is very easy, we rethrow the thrown exception.</p>
<pre><code class="c++">//! A constexpr source variable for the throw exception code domain to return via get()
constexpr inline _thrown_exception_domain thrown_exception_domain;
inline constexpr const _thrown_exception_domain *_thrown_exception_domain::get()
{
  return &amp;thrown_exception_domain;
}

// Helper to construct a thrown_exception_code from a std::exception_ptr
inline thrown_exception_code make_status_code(std::exception_ptr ep)
{
  return thrown_exception_code(in_place, exception_ptr_storage.add(std::move(ep)));
}
</code></pre>

<p>Finally, we need to implement the domain's static <code>get()</code> function
which returns a constexpr source of the domain from which codes of
this domain can initialise their reference to their domain. We
also declare a helper function <code>make_status_code()</code> which will
store an exception ptr into the global threadsafe storage and
return a <code>thrown_exception_code</code> referencing that stored thrown
exception.</p>
<p>Let's quickly see a use case:</p>
<pre><code class="c++">int main()
{
  thrown_exception_code tec(make_status_code(std::make_exception_ptr(std::bad_alloc())));
  system_code sc(tec);
  printf(&quot;Thrown exception code has message %s\n&quot;, sc.message().c_str());
  printf(&quot;Thrown exception code == errc::not_enough_memory = %d\n&quot;, sc == errc::not_enough_memory);
  return 0;
}
</code></pre>

<p>Because the size of <code>thrown_exception_code</code> is not bigger than
<code>system_code</code> and the value type is trivially copyable, <code>system_code</code>
which is a type erased form of status code will accept construction
from <code>thrown_exception_code</code>. This allows your functions to return
<code>system_code</code>, thus allowing multiple code domains to be returned.</p>
<p>If you would like to see this custom status code and domain in action,
you can find it in an online C++ compiler at
<a href="https://wandbox.org/permlink/cRDS3kWqcAmYHBD6">https://wandbox.org/permlink/cRDS3kWqcAmYHBD6</a>.</p></body>
</html>
